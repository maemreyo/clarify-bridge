//  Jira integration provider

import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import axios from 'axios';
import {
  IntegrationType,
  IntegrationProvider,
  IntegrationConfig,
  JiraConfig,
  SyncResult,
  ExportResult,
} from '../interfaces/integration.interface';

@Injectable()
export class JiraProvider implements IntegrationProvider {
  readonly type = IntegrationType.JIRA;
  private readonly logger = new Logger(JiraProvider.name);

  constructor(private configService: ConfigService) {}

  async validateConfig(config: IntegrationConfig): Promise<boolean> {
    const jiraConfig = config as JiraConfig;

    // Validate required fields
    if (!jiraConfig.domain || !jiraConfig.email || !jiraConfig.apiKey || !jiraConfig.projectKey) {
      return false;
    }

    // Test connection
    return this.testConnection(config);
  }

  async testConnection(config: IntegrationConfig): Promise<boolean> {
    const jiraConfig = config as JiraConfig;

    try {
      const response = await axios.get(`https://${jiraConfig.domain}/rest/api/3/myself`, {
        headers: {
          Authorization: `Basic ${Buffer.from(`${jiraConfig.email}:${jiraConfig.apiKey}`).toString('base64')}`,
          'Content-Type': 'application/json',
        },
      });

      return response.status === 200;
    } catch (error) {
      this.logger.error(`Jira connection test failed: ${error.message}`);
      return false;
    }
  }

  async sync(integration: any): Promise<SyncResult> {
    // TODO: Implement Jira sync logic
    this.logger.log(`Syncing Jira integration ${integration.id}`);

    return {
      status: 'success',
      message: 'Jira sync completed',
      syncedItems: 0,
    };
  }

  async exportSpecification(specification: any, config: IntegrationConfig): Promise<ExportResult> {
    const jiraConfig = config as JiraConfig;
    const version = specification.versions[0];

    try {
      // Create Jira issue
      const issueData = {
        fields: {
          project: { key: jiraConfig.projectKey },
          summary: specification.title,
          description: this.formatDescription(specification, version),
          issuetype: { id: jiraConfig.issueTypeId || '10001' }, // Story
        },
      };

      const response = await axios.post(
        `https://${jiraConfig.domain}/rest/api/3/issue`,
        issueData,
        {
          headers: {
            Authorization: `Basic ${Buffer.from(`${jiraConfig.email}:${jiraConfig.apiKey}`).toString('base64')}`,
            'Content-Type': 'application/json',
          },
        },
      );

      return {
        externalId: response.data.key,
        externalUrl: `https://${jiraConfig.domain}/browse/${response.data.key}`,
        provider: IntegrationType.JIRA,
        createdAt: new Date(),
      };
    } catch (error) {
      this.logger.error(`Failed to export to Jira: ${error.message}`);
      throw error;
    }
  }

  async processWebhook(integration: any, event: string, payload: any): Promise<void> {
    this.logger.log(`Processing Jira webhook: ${event}`);

    // TODO: Handle different Jira webhook events
    switch (event) {
      case 'issue:created':
        // Handle issue creation
        break;
      case 'issue:updated':
        // Handle issue update
        break;
      case 'comment:created':
        // Handle comment creation
        break;
      default:
        this.logger.warn(`Unhandled Jira webhook event: ${event}`);
    }
  }

  private formatDescription(specification: any, version: any): string {
    return `
**Description:**
${specification.description || 'N/A'}

**PM View:**
${JSON.stringify(version.pmView, null, 2)}

**Frontend View:**
${JSON.stringify(version.frontendView, null, 2)}

**Backend View:**
${JSON.stringify(version.backendView, null, 2)}

---
Generated by The Clarity Bridge
    `.trim();
  }
}

// ============================================
